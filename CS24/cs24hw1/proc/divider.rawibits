#   R3 = R1 >> 31   get most significant bit of divisor
#   R4 = R0 >> 31   get most significant bit of dividend
#   R4 = ~R4
#   BNZ R4, TOGGLEDIVIDEN   if positive, branch and skip, so we must toggle all negative bits to positive
#   R0 = R5 - R0            removes the leading 1 bit for sign
#   R3 = ~R3 (TOGGLEDIVIDEND:)
#   BNZ R3, TOOGLEDIVISOR     if positive, branch and skip, so we toggle positive bits to negative (no skip) 
#   R1 = R5 - R1
#   R7 = R0  (TOGGLEDIVISOR:)   set remainder = dividend, at this point, R6 = 0 due to reading from register
#   WHILE:
#   R7 = R7 - R1
#   R2 = R2 >> 31    extract sign bit, if negative (1), then we have broken condition of loop, then we exit to
#   BNZ R2, done           if remainder >= 0, we don't branch, we increment R6, else we goto DONE
#   R6 = R6 + 1
#   BNZ TRUE, WHILE        force goto while loop
#   DONE:
#   R7 = R7 + R1
#   BNZ R3, TOOGLEDIVISORAGAIN     if R3 is 0, this means we toggled before, so we toggle again(done skip) 
#   R1 = R5 - R1
#   BNZ R4, TOGGLEDIVIDENAGAIN  (TOOGLEDIVISORAGAIN:) if R4 is 0, this means we toggled before, so we toggle again(done skip) 
#   R0 = R5 - R0            removes the leading 1 bit for sign
#   R3 = R3 XOR R4  (TOGGLEDIVIDENAGAIN:) get sign of division, 1 for negative, 0 for positive
#   R3 = ~R3      if R3 is 1, meaning yes negate, then we toggle R3 to be zero so we don't skip the negate block
#   BNZ R3, RETURN
#   R7 = R5 - R7;
#   RETURN:

